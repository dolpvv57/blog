import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,d as t}from"./app-CONuJI3o.js";const p="/blog/assets/study/JVM/1.png",e="/blog/assets/study/JVM/2.png",i="/blog/assets/study/JVM/3.png",l="/blog/assets/study/JVM/4.png",o="/blog/assets/study/JVM/5.png",c={},r=t('<h2 id="_1-java内存区域详解" tabindex="-1"><a class="header-anchor" href="#_1-java内存区域详解" aria-hidden="true">#</a> 1. Java内存区域详解</h2><p>Java 程序运行时的数据区域有：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>堆可以是连续空间，也可以不连续；可以大小固定，也可以在运行时按需扩展。堆的唯一目的就是存放对象实例，几乎所有对象实例以及数组都在这里分配内存。堆最容易出现的错误就是 <mark>OutOfMemoryError</mark>。</p><p>Java 虚拟机栈（简称栈）是线程私有的，因此它的生命周期和线程相同。除了本地方法之外的所有方法调用都通过栈来实现，方法调用的数据也通过栈来进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，方法调用结束后则有个栈帧弹出。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，栈帧随着方法调用而创建，随着方法结束而销毁，无论方法正常完成还是异常完成都算作方法结束。</p><p>如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，且栈的内存大小不允许动态扩展的时候，就抛出 <mark>StackOverFlowError</mark> 错误；如果可以动态扩展，但是扩展时申请不到足够的内存空间，就抛出 <mark>OutOfMemoryError</mark> 异常。</p><p>元空间使用的是本地内存，是方法区的一种具体实现，所谓方法区，是一块逻辑区域，用来存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。运行时常量池用于存放编译期生成的各种字面量和符号引用的常量池，而为什么字符串常量池在堆中，是因为可以更高效及时地回收字符串内存。</p><h2 id="_2-java对象创建的过程" tabindex="-1"><a class="header-anchor" href="#_2-java对象创建的过程" aria-hidden="true">#</a> 2. Java对象创建的过程</h2><ol><li>类加载检查</li></ol><p>JVM遇到一条new指令，首先检查能否在常量池中定位到这个类的符号引用，检查这个符号引用代表的类是否已经加载、解析和初始化过。如果没有，就先执行相应的类加载过程。</p><ol start="2"><li>分配内存</li></ol><p>类加载检查通过后，给对象分配内存，也就是把一块确定大小的内存从 Java堆中划分出来，有两种方式分配：</p><ul><li>在堆的内存规整的情况下（没有内存碎片），这时候用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，指针向着没有用过的内存方向移动需要分配的内存大小位置（使用该分配方式的GC收集器：Serial，ParNew）</li><li>堆的内存不规整的情况下（有内存碎片），JVM会维护一个列表，里面记录哪些内存块是可用的，分配的时候，找一块足够大的内存块给对象实例，并且更新列表记录（使用该分配方式的GC收集器：CMS）</li></ul><blockquote><p>堆的内存是否规整，取决于GC收集器的算法是 “标记-清除”，还是 “标记-整理”</p></blockquote><p>如果分配内存时是多个线程并发进行的，JVM有两种方式保证线程安全：每个线程预先在 Eden 区分配一块内存，为这个线程的对象分配时优先在这一块预先分配好的内存里面分配，如果不够用，再去别的地方分配；在别的公共的地方分配时，使用CAS（乐观锁），即不加锁而假设没有冲突去完成某项操作，如果冲突失败就重试，直到成功。</p><ol start="3"><li>初始化零值</li></ol><p>将分配到的内存空间初始化为零值</p><ol start="4"><li>设置对象头</li></ol><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在【对象头】中。</p><ol start="5"><li>执行init方法</li></ol><p>按照程序员的意愿进行初始化</p><p>对象在内存中的布局，有三块区域：对象头、实例数据和对齐填充。对象头除了储存对象自身的运行时数据（哈希码、GC分代年龄、锁标志状态等等，还储存了类型指针，指向它的类的元数据，通过这个指针可以确定该对象是哪个类的实例。</p><h2 id="_3-jvm垃圾回收详解" tabindex="-1"><a class="header-anchor" href="#_3-jvm垃圾回收详解" aria-hidden="true">#</a> 3. JVM垃圾回收详解</h2><p>Java 自动内存管理最核心的功能是<mark>堆</mark>内存中对象的分配与回收，堆是垃圾收集器管理的主要区域，因此也被称作<mark>GC堆</mark>。</p><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上至下分别是新生代、老年代和元空间，元空间使用的是直接内存</p><h3 id="_1-内存分配和回收原则" tabindex="-1"><a class="header-anchor" href="#_1-内存分配和回收原则" aria-hidden="true">#</a> 1) 内存分配和回收原则</h3><p>对象优先在 Eden区分配，如果 Eden区 没有足够的空间进行分配时，JVM发起<mark>Minor GC</mark>，将 Eden区的对象转移至 S区；如果无法存入 S区，通过<strong>分配担保机制</strong>，将新生代对象提前转移到老年代中去。Minor GC进行完之后，在 Eden区给新对象分配内存。</p><p>大对象直接进入老年代，大对象指需要大量连续内存空间的对象（字符串、数组）可以根据参数设定阈值，决定哪些对象直接进入老年代，默认情况下，由JVM根据当前的堆内存情况和历史数据动态决定。</p><p>长期存活的对象进入老年代，每个对象有个年龄计数器，初次经历 Minor GC并转移到 S区后年龄变为1，之后每熬过一次 Minor GC年龄就 +1，到了一定的年龄就会转移至老年代。这个年龄是动态决定的，可以使用参数设置一个年龄阈值，同时 Hotspot遍历所有对象时，按照年龄从小到大的顺序对其所占用的内存进行累加，累加的内存超过 S区的50%，则取当前年龄和设置的年龄阈值的最小值作为实际的阈值。</p><p>什么时候进行 Minor GC，什么时候进行 Full GC？</p><p>只要老年代的连续空间大小 大于 新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则进行 Full GC</p><h3 id="_2-死亡对象的判断方法" tabindex="-1"><a class="header-anchor" href="#_2-死亡对象的判断方法" aria-hidden="true">#</a> 2) 死亡对象的判断方法</h3><p>对对象进行可达性分析：有一系列的对象作为起点，称为“GC Roots”，从这些节点开始向下搜索，节点走过的路径称为引用链，如果一个对象到 GC Roots 之间没有任何引用链的话，就说明该对象需要被回收。</p><p>哪些对象可以作为起点？</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="_3-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_3-垃圾收集器" aria-hidden="true">#</a> 3) 垃圾收集器</h3><p>JDK默认的垃圾收集器：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK 20：G1</li></ul><ol><li>Parallel Scavenge 和 Parallel Old 收集器</li></ol><p>新生代使用标记-复制算法，老年代使用标记-整理。它通过多线程并行地执行垃圾收集操作，目标是尽可能减少垃圾收集的停顿时间（Stop the world），以便应用程序能够以更高的吞吐量运行。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>CMS 收集器（JDK 14之后被弃用）</li></ol><p>主要针对老年代进行垃圾回收，基于标记-清除算法，CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，优点是并发收集、低停顿，所以用户体验好；但缺点是对 CPU 的使用率高（占比高），无法处理浮动垃圾，使用标记-清除算法会导致有大量内存空间碎片产生。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>G1 收集器</li></ol><p>G1 能充分利用多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿时间，并且可以预测停顿时间。从整体来看，G1是基于标记-整理算法实现的收集器，而从局部来看是基于标记-复制实现的。具体来说，选定了要回收垃圾的 Region，就将该区域的存活对象复制进 S区，然后清除该区域。</p><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间（收集时间默认值是200ms，可以由参数设定），优先选择回收价值最大的 Region（它的名字 Garbage-First 的由来）。什么是最大回收价值呢？也就是垃圾最多的 Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率。 从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</p><figure><img src="'+o+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在G1之前，年轻代、老年代、元空间（或者永久代）的内存空间是固定的，且它们是连续的内存。G1则把内存划分成一个个大小固定的region，在运行时可以动态地调整，把这些region划分成Eden区、S区、老年代等等。另外增加了一个H区，专门用来存储大对象，大对象是个相对概念，指所占内存超过了一个region的 50%。</p><h2 id="_4-类加载" tabindex="-1"><a class="header-anchor" href="#_4-类加载" aria-hidden="true">#</a> 4. 类加载</h2><p>每个类的类加载只会执行一次，当每个类被<mark>首次加载</mark>到JVM时，会执行静态代码块。当发生多态的时候，会先执行父类的静态代码块，再执行子类的静态代码块，比如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是父类: 静态代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是父类: 构造方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是子类: 静态代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是子类: 构造方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Father</span> fa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 首次加载父类和子类</span>
    <span class="token comment">// 输出：</span>
    <span class="token comment">// 我是父类: 静态代码块</span>
    <span class="token comment">// 我是子类: 静态代码块</span>
    <span class="token comment">// 我是父类: 构造方法</span>
    <span class="token comment">// 我是子类: 构造方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54),u=[r];function d(k,m){return a(),s("div",null,u)}const h=n(c,[["render",d],["__file","JVM.html.vue"]]);export{h as default};
