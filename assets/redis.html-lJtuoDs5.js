import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,d as p}from"./app-CONuJI3o.js";const t="/blog/assets/pic/2.webp",e="/blog/assets/pic/3.webp",o="/blog/assets/pic/4.webp",c={},i=p(`<h2 id="什么是redis" tabindex="-1"><a class="header-anchor" href="#什么是redis" aria-hidden="true">#</a> 什么是Redis</h2><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。Redis 提供了多种数据类型来支持不同的业务场景，并且【对数据类型的操作都是原子性】的，因为执行命令由单线程负责</p><p>Redis 具备高性能、高并发两种特性，因此<mark>使用 Redis 作为 MySQL 的缓存</mark></p><p>注：单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w</p><p>Spring Boot 整合 Redis：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 Redis 来说，所有 key 都是字符串，它的基础数据结构，指的都是存储值的数据类型，包括常见的 5 种数据类型，分别是：String、List、Set、Zset、Hash</p><p>Spring 通过模板方式（RedisTemplate）提供了对 Redis 的数据查询和操作功能，RedisTemplate 对于 Redis 5种基础类型的操作有：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作字符串</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 操作hash</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 操作list</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 操作set</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">opsForZSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 操作zset</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="redis实现缓存" tabindex="-1"><a class="header-anchor" href="#redis实现缓存" aria-hidden="true">#</a> Redis实现缓存</h2><p>当在 Spring Boot 默认缓存管理的基础上引入 Redis 缓存组件，即在 pom.xml 文件中添加 Spring Data Redis 依赖启动器后，SpringBoot 会使用 <code>RedisCacheConfigratioin</code> 当做生效的自动配置类进行缓存相关的自动装配，容器中使用的缓存管理器是 <code>RedisCacheManager</code>, 这个缓存管理器创建的 Cache 为 RedisCache, 进而操控 Redis 进行数据的缓存</p><p>核心思想：当我们调用一个方法时会把该方法的参数和返回结果最为一个键值对存放在缓存中，等下次利用同样的参数来调用该方法时将不会再执行，而是直接从缓存中获取结果进行返回</p><p>使用到的注解：</p><ul><li><code>@EnableCaching</code>：开启缓存功能</li><li><code>@Cacheable</code>：调用方法前先去缓存中找，找到就返回，找不到就执行方法，并将返回值放到缓存中</li><li><code>@CachePut</code>：方法调用前不会去缓存中找，无论如何都会执行方法，执行完将返回值放到缓存中</li><li><code>@CacheEvict</code>：清理缓存中的一个或多个记录</li></ul><p>构建 Redis 配置类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>dolpvv<span class="token punctuation">.</span>ssmp<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">JsonAutoDetect</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">PropertyAccessor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">ObjectMapper</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">CachingConfigurerSupport</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">EnableCaching</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cache<span class="token punctuation">.</span></span><span class="token class-name">RedisCacheConfiguration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cache<span class="token punctuation">.</span></span><span class="token class-name">RedisCacheManager</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span></span><span class="token class-name">RedisConnectionFactory</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">Duration</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@EnableCaching</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisCacheManager</span> <span class="token function">redisCacheManager</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 字符串序列化器</span>
        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringRedisSerializer <span class="token operator">=</span> 
            <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// JSON 序列化器</span>
        <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> jsonRedisSerializer <span class="token operator">=</span> 
            <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span><span class="token constant">ALL</span><span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span><span class="token constant">ANY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">RedisCacheConfiguration</span> config <span class="token operator">=</span> <span class="token class-name">RedisCacheConfiguration</span>
            <span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofDays</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 缓存的有效期是 3 天</span>
            <span class="token punctuation">.</span><span class="token function">serializeKeysWith</span><span class="token punctuation">(</span>
                <span class="token class-name">RedisSerializationContext
                <span class="token punctuation">.</span>SerializationPair</span>
                <span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span>
            <span class="token punctuation">)</span>  <span class="token comment">// 将键对象序列化为字符串</span>
            <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span>
                <span class="token class-name">RedisSerializationContext
                <span class="token punctuation">.</span>SerializationPair</span>
                <span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span>
            <span class="token punctuation">)</span>  <span class="token comment">// 将值对象序列化为 JSON</span>
            <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置 Redis 连接池（在 Properties 文件中）</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token operator">-</span>active<span class="token operator">=</span><span class="token number">8</span>
spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">8</span>
spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">0</span>
spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>pool<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token operator">-</span>wait<span class="token operator">=</span><span class="token operator">-</span>1ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="旁路缓存策略" tabindex="-1"><a class="header-anchor" href="#旁路缓存策略" aria-hidden="true">#</a> 旁路缓存策略</h2><p>数据库和缓存如何保证一致性？先更新数据库，再删除缓存</p><p>Redis 采用的是旁路缓存策略（Cache Aside），即进行读操作时，先查询缓存是否命中，如果命中则直接返回，如果没有命中，则在数据库中查询，将结果存入缓存中再返回（由注解 <mark>@Cacheable</mark> 实现）</p><p>如果更新了数据库（在本项目中，对应清除当前告警的操作，相当于把 cleared 修改为 1）先更新数据库再删除缓存的做法可以有效规避数据库和缓存不一致的问题，因为缓存的写入速度远远快于数据库的写入（由注解 <mark>@CacheEvict</mark> 实现）</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@CacheEvict</span>
<span class="token annotation punctuation">@PostMapping</span>
<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">clearByIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotEmpty</span> <span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> csnList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FMData</span><span class="token punctuation">&gt;</span></span> fmDataList <span class="token operator">=</span> iDataService<span class="token punctuation">.</span><span class="token function">listByIds</span><span class="token punctuation">(</span>csnList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fmDataList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        item<span class="token punctuation">.</span><span class="token function">setCleared</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span>iDataService<span class="token punctuation">.</span><span class="token function">updateBatchById</span><span class="token punctuation">(</span>fmDataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@TODO：异步加消息队列保证数据库和redis的一致性？</p><h2 id="redis如何实现服务高可用" tabindex="-1"><a class="header-anchor" href="#redis如何实现服务高可用" aria-hidden="true">#</a> Redis如何实现服务高可用</h2><p>Redis 一句话总结：高性能、高并发</p><p>数据存储在多台服务器上，避免单点故障</p><p>【主从复制模式】是 Redis 高可用服务最基础的保证，从一台主 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式</p><p>主从服务器之间采用读写分离的方式，主服务器可以进行读写操作，写操作时自动将写操作同步给从服务器；从服务器一般是只读，并接收执行主服务器同步过来的写命令</p><p>写操作同步命令是异步执行的，主服务器不会等从服务器执行完写命令后再返回给客户端，而是自己执行完就直接返回</p><h3 id="详解主从服务器的同步过程" tabindex="-1"><a class="header-anchor" href="#详解主从服务器的同步过程" aria-hidden="true">#</a> 详解主从服务器的同步过程</h3><p>主从服务器间的第一次同步的过程可分为三个阶段：</p><ol><li>建立链接、协商同步；</li><li>同步数据给从服务器；</li><li>主服务器发送新的写操作命令给从服务器。</li></ol><figure><img src="`+t+`" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>第一阶段中，从服务器执行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>replicaof <span class="token operator">&lt;</span>服务器 A 的 IP 地址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>服务器 A 的 Redis 端口号<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接着就会将服务器 A 当作主服务器，并且与主服务器进行第一次同步，建立链接时发送的 <code>psync</code> 命令包含两个参数，分别是 主服务器的 runID 和复制进度 offset，由于初始时不知道 runID，因此用 <code>?</code> 表示</p><p>第二阶段中，生成和传输 RDB 文件是两件耗时的操作，因此可以设置部分从服务器分摊主服务器的压力，同样是使用 <code>replicaof</code> 命令复制：</p><figure><img src="`+e+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>主从服务器完成第一次同步后，双方之间维护一个 TCP 连接，且该连接是<mark>长连接</mark>，后续主服务器通过这个连接继续将写操作命令传播给从服务器，以保证各服务器的数据库状态相同</p><p>如果中途连接断开，后续又恢复，主从服务器之间不会重新进行一次全量复制，而是【增量复制】，即 把网络断开期间 主服务器收到的写命令，同步给从服务器</p><p>如何知道需要同步哪些增量数据？主从服务器有各自的偏移量，主服务器使用偏移量记录自己写的位置，从服务器则使用偏移量记录自己读的位置</p><p>偏移量指缓冲区 <code>repl_backlog_buffer</code> 中的偏移量，这是个环形的缓冲区，默认大小是 1M，写满后会覆盖之前的数据，因此如果判断从服务器要读取的数据已经不在缓冲区内了，那么就会采取【全量复制】的方式（减少全量复制的次数，可以适当调大缓冲区的方式）</p><h3 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h3><p>哨兵，即监控主从服务器的组件，本质上是一个运行在特殊模式下的 Redis 进程，提供主从故障转移的功能，也就是如果发现主节点挂了，会选举一个节点切换成主节点，并将新的主节点信息通知给从节点和客户端</p><p>实际部署的时候，不会只部署一个节点，而是使用多个节点部署成【哨兵集群】（最少需要三台机器）通过多个哨兵节点一起判断，避免单个哨兵由于自身网络状况不好而出现误判的情况</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>配置文件中可以设置 当哨兵的赞同票数达到多少时，主节点被标记为 客观下线</p><p>哨兵节点之间通过 Redis 的发布者/订阅者机制相互感知、相互连接（搭建哨兵集群时只需要配置主哨兵节点的名字、IP 地址、端口号和 quorum 值）</p><h2 id="redis集群脑裂导致数据丢失怎么办" tabindex="-1"><a class="header-anchor" href="#redis集群脑裂导致数据丢失怎么办" aria-hidden="true">#</a> Redis集群脑裂导致数据丢失怎么办？</h2><p>脑裂现象：主节点的网络出现问题，和其他所有从节点都断联，但主节点和客户端之间的网络是正常的（可以进行正常的写操作）这是哨兵集群认为主节点挂了，于是重新推选出一个节点作为主节点，这时候集群中出现两个主节点 —— 脑裂</p><p>等网络恢复，旧的主节点降级变为从节点，在与新的主节点进行同步复制的时候【这时候是第一次同步】，会清空自己原本的缓冲区，全量复制新主节点的复制，导致网络故障时期 客户端写入的数据丢失</p><p>解决方案：</p><p>在 Redis 配置文件中设置参数：</p><ul><li><code>min-slaves-to-write</code>：主节点必须有 x 个从节点连接，否则禁止客户端写入数据</li><li><code>min-slaves-max-lag</code>：主从复制和同步的延迟不能超过 x 秒，否则禁止写数据</li></ul><p>此时如果发生网络故障，旧的主节点会被限制接收客户端的写入请求，只能等新的主节点上线后接收并处理客户端请求，旧的主节点降为从节点后，不会因为数据情况而导致数据丢失</p><h2 id="redis为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis为什么这么快" aria-hidden="true">#</a> Redis为什么这么快</h2><p>首先总结：</p><ol><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发出一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；</li><li>Redis 内置了多种优化后的数据结构实现，性能很高。</li></ol><h3 id="详解-redis-的线程模型" tabindex="-1"><a class="header-anchor" href="#详解-redis-的线程模型" aria-hidden="true">#</a> 详解 Redis 的线程模型</h3><p>Redis 单线程指的是：接收客户端请求 -&gt; 解析请求 -&gt; 进行数据读写等操作 -&gt; 发送数据给客户端 这个过程由一个主线程完成（6.0 版本后引入多线程处理网络 IO 读写，但无论是什么版本，工作线程都只有一个）</p><p>第一个阶段，如何接收客户端请求？</p><p>使用 IO 多路复用技术，具体来说，使用 epoll 监听多个 socket，将要监听的文件描述符和对应的事件注册到内核态的一个 epoll 对象（底层数据结构是红黑树），如果监听到活跃的事件，就返回事件的个数（有多少文件描述符就绪）和结构体数组，主线程处理返回的数组</p><p>注：Javaer 习惯把基于 epoll 的网络开发模型叫做 NIO，这类基于实现注册事件分发器的开发模式也叫 Reactor 模型</p><p>具体说说 Reactor：</p><p>Reactor 通过 epoll(IO 多路复用接口) 监听事件，收到事件后通过 dispatch 进行分发，根据事件类型决定是分发给 Acceptor 还是 Handler</p><ul><li>如果是建立连接的事件，则发给 Acceptor，通过 accept 方法获取连接，并且创建一个 Handler 对象处理后续的响应事件；</li><li>其他事件发给 Handler 进行处理</li></ul><p>重点来啦，既然是单线程，为什么这么快呢？</p><ol><li>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题；</li><li>Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，这种机制允许内核一直监听这些 Socket 上的连接请求或数据请求，一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ol>',69),l=[i];function u(r,d){return s(),a("div",null,l)}const v=n(c,[["render",u],["__file","redis.html.vue"]]);export{v as default};
