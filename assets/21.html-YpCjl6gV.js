const e=JSON.parse(`{"key":"v-0d578ea2","path":"/posts/Java/21.html","title":"21 并发","lang":"zh-CN","frontmatter":{"description":"21 并发 21.3 共享受限资源 synchronized关键字 synchronized可以加到方法前面，表示对方法上锁；也可以加到代码块前面，如果加到代码块前面，就一定要在括号内指定一个锁，这个锁可以是一个对象，也可以是一个类 所有对象自动含有单一的锁，在该对象上调用任意的被synchronized修饰的方法都会对对象进行加锁，加锁后该对象其他所有的synchronized修饰的方法都不能用。 使用并发时最好将域设置为private，否则synchronized不能防止其他任务直接访问域","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/Java/21.html"}],["meta",{"property":"og:site_name","content":"Becky's"}],["meta",{"property":"og:title","content":"21 并发"}],["meta",{"property":"og:description","content":"21 并发 21.3 共享受限资源 synchronized关键字 synchronized可以加到方法前面，表示对方法上锁；也可以加到代码块前面，如果加到代码块前面，就一定要在括号内指定一个锁，这个锁可以是一个对象，也可以是一个类 所有对象自动含有单一的锁，在该对象上调用任意的被synchronized修饰的方法都会对对象进行加锁，加锁后该对象其他所有的synchronized修饰的方法都不能用。 使用并发时最好将域设置为private，否则synchronized不能防止其他任务直接访问域"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Becky"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"21 并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Becky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"21.3 共享受限资源","slug":"_21-3-共享受限资源","link":"#_21-3-共享受限资源","children":[{"level":3,"title":"synchronized关键字","slug":"synchronized关键字","link":"#synchronized关键字","children":[]},{"level":3,"title":"显式的Lock对象: ReentrantLock","slug":"显式的lock对象-reentrantlock","link":"#显式的lock对象-reentrantlock","children":[]}]},{"level":2,"title":"21.8 线程池","slug":"_21-8-线程池","link":"#_21-8-线程池","children":[{"level":3,"title":"什么是线程池","slug":"什么是线程池","link":"#什么是线程池","children":[]},{"level":3,"title":"如何创建线程池：ThreadPoolExecutor","slug":"如何创建线程池-threadpoolexecutor","link":"#如何创建线程池-threadpoolexecutor","children":[]},{"level":3,"title":"提交一个任务后会发生什么","slug":"提交一个任务后会发生什么","link":"#提交一个任务后会发生什么","children":[]},{"level":3,"title":"内部实现：线程复用的原理","slug":"内部实现-线程复用的原理","link":"#内部实现-线程复用的原理","children":[]}]}],"git":{},"readingTime":{"minutes":4.38,"words":1313},"filePathRelative":"posts/Java/21.md","excerpt":"<h1> 21 并发</h1>\\n<h2> 21.3 共享受限资源</h2>\\n<h3> synchronized关键字</h3>\\n<p><code>synchronized</code>可以加到方法前面，表示对方法上锁；也可以加到代码块前面，如果加到代码块前面，就一定要在括号内指定一个锁，这个锁可以是一个对象，也可以是一个类</p>\\n<p><mark>所有对象自动含有单一的锁</mark>，在该对象上调用任意的被<code>synchronized</code>修饰的方法都会对对象进行加锁，加锁后该对象其他所有的<code>synchronized</code>修饰的方法都不能用。</p>\\n<blockquote>\\n<p>使用并发时最好将域设置为private，否则synchronized不能防止其他任务直接访问域</p>\\n</blockquote>","autoDesc":true}`);export{e as data};
