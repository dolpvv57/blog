import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as o,d as c}from"./app-CONuJI3o.js";const l="/blog/assets/study/Java/3.png",a={},i=c('<h1 id="_17-容器" tabindex="-1"><a class="header-anchor" href="#_17-容器" aria-hidden="true">#</a> 17 容器</h1><p>容器保存的是对象，由两大接口派生而来：Collection和Map</p><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h2><p><img src="'+l+`" alt="" loading="lazy"> Collection接口下有3个子接口，分别是List、Set、Queue</p><ul><li><code>List</code>：有序（按照插入顺序）可根据索引查找</li><li><code>Set</code>：没有重复元素的集合</li><li><code>Queue</code>：模拟队列，先进先出</li></ul><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><p>以数组为基础实现</p><ul><li><p><code>Vector</code>，<code>ArrayList</code>：本质是动态数组（<code>Object[]</code>数组），存储顺序与插入顺序一致，随机访问快，插入删除慢。二者区别在于<code>Vector</code>线程安全（所有函数都添加了<code>synchronized</code>关键字）<code>ArrayList</code>线程不安全。<code>Vector</code>性能更差</p><ul><li><code>ArrayList</code>底层使用elementData来存储数据</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>transient Object[] elementData;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>LinkedList</code>：双向链表，存储顺序与插入顺序一致，查询慢，需要移动指针遍历，插入删除快。性能没有<code>ArrayList</code>好，且线程不安全</p><ul><li><code>LinkedList</code>没有实现<code>RandomAccess</code>接口，<code>ArrayList</code>有实现</li></ul></li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><p>无序且不包含重复元素</p><ul><li><code>HashSet</code>：底层是哈希表（基于<code>HashMap</code>实现）不允许重复元素，允许有null元素。线程不安全</li><li><code>LinkedHashSet</code>：底层是链表和哈希表，是上者的子类，同样根据元素的HashCode决定元素的存储位置，使用链表维护元素的次序。线程不安全</li><li><code>TreeSet</code>：底层是红黑树，有序且唯一。线程不安全 <code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO（先进先出）的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h3 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h3><ul><li><code>PriorityQueue</code>：底层使用二叉堆的数据结构实现，按照队列元素的大小进行排序（默认由小到大，即小顶堆）元素必须是可比较的（即实现了<code>Comparable</code>接口）线程不安全 <ul><li>插入和删除元素的时间复杂度是O(log n)</li></ul></li><li><code>BlockingQueue</code>：是一个接口，表示阻塞队列，常用于生产者-消费者模型</li></ul><h3 id="deque" tabindex="-1"><a class="header-anchor" href="#deque" aria-hidden="true">#</a> Deque</h3><p>是Queue下的子接口，双端队列，也可以当作栈来使用</p><ul><li><code>ArrayDeque</code>：本质是循环数组</li></ul><blockquote><p><code>ArrayDeque</code>和<code>LinkedList</code>都实现了Deque接口，二者均具有队列的功能，那二者有何区别？</p></blockquote><ol><li><code>ArrayDeque</code>基于可变长的数组与双指针来实现，<code>LinkedList</code>基于链表实现</li><li><code>ArrayDeque</code>不支持存储null数据，<code>LinkedList</code>则支持</li><li><code>ArrayDeque</code>插入时可能存在扩容过程，但均摊后插入操作的时间复杂度仍然为O(1)；<code>LinkedList</code>不存在扩容，但每次插入数据时均需要申请新的堆空间，均摊性能相比更慢</li></ol><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><p>存储键值对的集合，不能有重复的key，每个key最多对应一个value</p><ul><li><p><code>HashMap</code>：本质是由数组+链表组成的，当链表长度大于阈值时，如果数组长度小于64，会先进行扩容；如果数组长度大于64，则将链表转换成红黑树。可以使用null作为key或value，散列表，通过链地址法解决冲突。<span style="color:rgb(255,0,0);">线程不安全</span></p><ul><li>key判断相等的标准是，两个key通过<code>equals</code>方法比较返回true，且两个key的<code>hashCode</code>也相等</li><li>value判断相等的标准是，两个value通过<code>equals</code>方法比较返回true</li></ul></li><li><p><code>LinkedHashMap</code></p></li><li><p><code>Hashtable</code>：由数组+链表组成，数组是主体，链表是为了解决哈希冲突。不可以使用null作为key或value，与上者的区别是数组位置index的计算方式不同，且<span style="color:rgb(255,0,0);">线程安全</span>【不高效，基本淘汰】</p></li><li><p><code>CurrentHashMap</code>：key和value都不可以插入null。解决上者对整个哈希表结构进行锁定操作的缺陷，<code>CurrentHashMap</code>在JDK1.7采用分段加锁的技术，JDK1.8则采用node数组+链表/红黑树，对node加锁。只要hash不冲突，就不会产生并发，即不会影响其他node的读写，效率大幅提升，<span style="color:rgb(255,0,0);">线程安全</span></p><ul><li><p>JDK1.7 分段加锁，数组 + 链表</p></li><li><p>JDK1.8 node + CAS + synchronized，数组 + 链表 + 红黑树</p></li></ul></li><li><p><code>TreeMap</code>：由红黑树实现，每个键值对即为红黑树的一个节点。自动排序</p></li></ul>`,21),t=[i];function r(s,n){return d(),o("div",null,t)}const p=e(a,[["render",r],["__file","17.html.vue"]]);export{p as default};
