import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as t,d as i}from"./app-CONuJI3o.js";const d="/blog/assets/study/mysql/1.webp",l="/blog/assets/study/mysql/2.webp",n="/blog/assets/study/mysql/3.webp",s="/blog/assets/study/mysql/4.webp",r="/blog/assets/study/mysql/5.webp",o={},c=i('<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><p>MySQL 数据类型包括：</p><table><thead><tr><th></th><th>byte(s)</th><th>desc</th></tr></thead><tbody><tr><td>tinyint</td><td>1</td><td></td></tr><tr><td>smallint</td><td>2</td><td></td></tr><tr><td>mediumint</td><td>3</td><td></td></tr><tr><td>int</td><td>4</td><td></td></tr><tr><td>bigint</td><td>8</td><td></td></tr><tr><td>float</td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td>double(总长度，小数点后保留的位数)</td></tr><tr><td>date</td><td>3</td><td></td></tr><tr><td>time</td><td>3</td><td></td></tr><tr><td>year</td><td>1</td><td></td></tr><tr><td>datetime</td><td>8</td><td></td></tr><tr><td>char</td><td>0-255</td><td>定长，字符空间是确定的，性能更高</td></tr><tr><td>varchar</td><td>0-65535</td><td>变长，根据长度分配内存空间，节约空间</td></tr></tbody></table><p>设计表格的时候，<code>int(10)</code>、<code>char(10)</code>、<code>varchar(10)</code>有什么区别？</p><ul><li><code>int(10)</code>: 这表示一个整数类型的列，括号中的数字不影响存储大小或取值范围，而是指定显示宽度，仅用于显示，不会对存储或计算产生影响。例如，<code>int(10)</code>和<code>int(5)</code>在存储和计算上是完全相同的。括号中的数字通常用于在查询结果中对整数进行对齐。</li><li><code>char(10)</code>: 这表示一个固定长度的字符列，其中括号中的数字指定了列能够存储的字符数。如果存储的字符串长度小于指定的长度，MySQL会使用空格来填充剩余的空间。例如，如果存储的字符串是&quot;abc&quot;，而列定义为<code>char(10)</code>，则存储的实际内容为&quot;abc(space)(space)(space)(space)(space)(space)(space)&quot;（其中的空格表示填充）</li><li><code>varchar(10)</code>: 这表示一个可变长度的字符列，其中括号中的数字指定了列能够存储的最大字符数。与<code>char</code>不同，<code>varchar</code>只会占用实际存储的字符数加上一些额外的存储空间来记录字符串长度的信息。例如，如果存储的字符串是&quot;abc&quot;，而列定义为<code>varchar(10)</code>，则只会占用3个字符的存储空间。</li></ul><p>数据库设计有3种方式：</p><ul><li>多对一：在多的一方建立外键，指向一的一方的主键</li><li>多对多：借助中间表，中间表包含两个外键，分别指向关联两方的主键</li><li>一对一：多用于表拆分，在任意一方加入外键，关联另一方的主键（设置外键为唯一）</li></ul><h3 id="执行select会发生什么" tabindex="-1"><a class="header-anchor" href="#执行select会发生什么" aria-hidden="true">#</a> 执行SELECT会发生什么</h3><p>MySQL 的架构分为两层：Server 层和存储引擎层</p><ul><li>Server 层负责建立连接、分析和执行 SQL</li><li>存储引擎层负责数据的存储和提取，不同的存储引擎共用一个 server 层，InnoDB 是 MySQL 的默认存储引擎，索引数据结构就是由存储引擎实现的，不同引擎支持的索引类型不同，比如 InnoDB 支持的索引类型是 B+ 树</li></ul><p>整体流程图：</p><figure><img src="'+d+'" alt="查询语句执行流程" tabindex="0" loading="lazy"><figcaption>查询语句执行流程</figcaption></figure><ol><li><mark>连接器</mark>：连接 MySQL 服务，连接的过程需要进行三次握手，因为 MySQL 是基于 TCP 协议进行传输的；一次连接对应一次权限检查，中途修改用户权限不会影响已经存在的连接</li><li><mark>查询缓存</mark>：对于更新频繁的表，查询缓存的命中率很低，因此【MySQL 8.0 版本直接将查询缓存删掉了】</li><li><mark>解析器</mark>：负责对 SQL 语句进行词法分析和语法分析</li><li><mark>预处理器</mark>：做两件事情，1）检查 SQL 查询语句中的表或字段是否存在；2）将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列</li><li><mark>优化器</mark>：将 SQL 查询语句的执行方案确定下来，比如确定使用哪个索引</li><li><mark>执行器</mark>：和存储引擎交互</li></ol><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><p>并行事务可能引发的问题：脏读，不可重复读，幻读</p><ul><li>脏读：一个事务读到了另一个【未提交事务】修改过的数据</li><li>不可重复读：在一个事务内多次读取【同一个数据】，前后两次读到的数据不一样</li><li>幻读：在一个事务内多次查询某个符合查询条件的【记录数量】，前后两次查询到的记录数量不一样</li></ul><p>严重性排序：脏读 &gt; 不可重复读 &gt; 幻读</p><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h3><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低：</p><ul><li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；</li><li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<span style="color:rgb(230,73,25);">MySQL InnoDB 引擎的默认隔离级别</span>；</li><li>串行化（serializable ），会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>各种隔离级别可以规避的问题：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h4 id="可重复读是如何工作的" tabindex="-1"><a class="header-anchor" href="#可重复读是如何工作的" aria-hidden="true">#</a> 可重复读是如何工作的</h4><p>在启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，Read View 记录了此时活跃事务 id 列表的最小值和最大值，读取数据时，会判断这条记录的事务 id 是否在范围内，如果是，就会往下找旧版本的事务，直到对应的事务 id 小于 Read View 中存的事务 id 最小值。</p><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="什么是回表" tabindex="-1"><a class="header-anchor" href="#什么是回表" aria-hidden="true">#</a> 什么是回表</h3><p>首先总结：</p><p>如果某个查询语句使用了二级索引（非聚簇索引，key是索引，value是主键值），但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作<mark>回表</mark>，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作【索引覆盖】，也就是只需要查一个 B+ 树就能找到数据</p><p>一步步理解：</p><h3 id="数据存储结构" tabindex="-1"><a class="header-anchor" href="#数据存储结构" aria-hidden="true">#</a> 数据存储结构</h3><p>整体印象：</p><p>B+树 -&gt; 树的每个节点是数据页 -&gt; 数据页由多个槽组成，数据页有页目录记录槽的相对位置 -&gt; 每个槽有多行记录</p><p>具体说明：</p><p>InnoDB 的数据是按【数据页】为单位来读写，数据页的默认大小是【16kb】，一次最少从磁盘中读取 16kb 的内容到内存中，一次最少把内存中的 16kb 内容刷新到磁盘中</p><p>数据页的结构包括文件头、页头、最大最小记录、用户记录、空闲空间、页目录、文件尾，在文件头(File Header)中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表：（采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续）</p><figure><img src="'+n+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>用户记录(User Records)本身是<u>按照主键的顺序</u>组成<mark>单向链表</mark>，页目录(Page Directory)的作用是存储用户记录的相对位置，对记录起到索引作用。页目录如何创建的呢？</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（粉红色字段）</li><li>页目录用来存储【每组】最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针，指向了不同组的最后一个记录</li></ol><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>页目录就是由多个槽组成的，槽相当于分组记录的索引。由于记录是按照【主键值】从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表【先定位到槽，再找记录】</p><p>InnoDB 采用 B+ 树作为索引，B+ 树中的每个节点都是一个数据页：</p><figure><img src="'+r+`" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>它的特点是：只有叶子节点（最底层的节点）存放了数据，非叶子节点仅仅用来存放目录项作为索引；非叶子节点分为不同层次，通过分层来降低每一层的搜索量；叶子节点构成一个<mark>双向链表</mark></p><p>数据库的索引和数据都是存储在硬盘内的，把读取一个节点当作一次磁盘 I/O 操作。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以 B+Tree 相比于 B 树和二叉树来说，<mark>最大的优势在于查询效率很高</mark>，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次</p><p>索引可以分成聚簇索引和非聚簇索引（二级索引），区别在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>非聚簇索引（二级索引）的叶子节点存放的是主键值，而不是实际数据</li></ul><p>对于一张表来说，聚簇索引一定会有并且只能有一个（数据在物理上只保存一份），如果有主键，默认会使用主键作为聚簇索引的索引键；如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；在前面两个都没有的情况下，InnoDB 会自动生成一个隐式自增 id 列作为聚簇索引的索引键</p><p>因此，如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作<mark>回表</mark>，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作【索引覆盖】，也就是只需要查一个 B+ 树就能找到数据</p><p>怎么避免回表？</p><p>原来的查询语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> alarm_id<span class="token punctuation">,</span> alarm_name<span class="token punctuation">,</span> occur_utc
<span class="token keyword">FROM</span> fmdata
<span class="token keyword">WHERE</span> alarm_id <span class="token operator">=</span> <span class="token string">&#39;200&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化后的查询语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> alarm_id<span class="token punctuation">,</span> alarm_name<span class="token punctuation">,</span> occur_utc
<span class="token keyword">FROM</span> fmdata t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> csn <span class="token keyword">from</span> fmdata <span class="token keyword">where</span> alarm_id <span class="token operator">=</span> <span class="token string">&#39;200&#39;</span><span class="token punctuation">)</span> t2 
<span class="token keyword">ON</span> t1<span class="token punctuation">.</span>csn  <span class="token operator">=</span> t2<span class="token punctuation">.</span>csn<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以有效减少回表操作，因为不需要每条数据都去聚簇索引回表查询，而是在二级索引中找出所有符合条件的 scn 后，从聚簇索引中拿出数据。实际操作上二者查询时间相差不大，猜想是 MySQL 内部对前者进行了优化</p><h3 id="mysql为什么喜欢b-树" tabindex="-1"><a class="header-anchor" href="#mysql为什么喜欢b-树" aria-hidden="true">#</a> MySQL为什么喜欢B+树</h3><p>查询时，二分查找的效率更高，这就要求索引数据最好能按顺序排列</p><p>如果使用二分查找树：存在极端情况，如果每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成一条链表，查找数据的时间复杂度就变成了 O(n)</p><p>如果使用平衡二叉树：同样会随着插入元素的增多，导致树的高度变高，意味着磁盘 I/O 操作次数变多（读取一个节点当作一次磁盘 I/O 操作），影响整体数据查询的效率（红黑树同理）这是每个节点只能保存 2 个子节点的天然缺陷</p><p>B 树：每个节点可以有多个子节点，但 B 树的每个节点都包含数据，如果查询位于底层的某个节点，那么其上层的数据也会从磁盘加载到内存，但这些数据是没用的，我们需要的只是索引；再者 B 树的叶子节点没有使用链表进行串联，不利于范围查询</p><p>B+ 树：叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引。非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）</p><p>B+ 树存在冗余节点，而 B 树没有，所以 B+ 树在删除某些节点的时候，甚至不需要动非叶子节点，即使删除的是根节点，也不会涉及到太过复杂的树形变化。因此 B+ 树的插入删除效率更高</p><p>哈希表不适合范围查询</p><h3 id="什么是联合索引" tabindex="-1"><a class="header-anchor" href="#什么是联合索引" aria-hidden="true">#</a> 什么是联合索引</h3><p>联合索引的非叶子节点，使用两个/多个字段（也就是作为索引的字段）的值作为 key，存在<mark>最左匹配原则</mark>，先按第一个字段排序，如果第一个字段相同，再比较第二个字段。</p><p>如果查询语句中where后面只有第二个or第三个字段，那么联合索引会失效（无法匹配上索引），因为没有遵循最左匹配原则。</p><h3 id="优化索引的方法" tabindex="-1"><a class="header-anchor" href="#优化索引的方法" aria-hidden="true">#</a> 优化索引的方法</h3><h4 id="explain" tabindex="-1"><a class="header-anchor" href="#explain" aria-hidden="true">#</a> Explain</h4><ul><li><code>id</code> 列：值越大优先级越高，id 相同则表示按照计划从上往下执行，id 为空表示最后执行</li><li><code>select_type</code> 列： <ul><li>simple 表示不包含子查询和 union 的简单查询</li><li>primary 表示复杂查询中最外层的 select</li><li>subquery 表示包含在 select 中的子查询</li><li>derived 表示包含在 from 子句中的子查询，Mysql 将此查询结果放入一个临时表中</li><li>union 表示在 union 中的第二个和随后的 select，union result 表示合并的结果</li></ul></li><li><code>table</code> 列：当前所在表</li><li><code>partitions</code> 列：查询匹配记录的分区，对于非分区表，该值为 NULL</li><li>🌟<code>type</code> 列：表示关联类型或访问类型，即 MySQL 决定如何查找表中的行，从最优到最差依次是 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</strong><ul><li>如果是 null，表示 MySQL 能在优化阶段分解查询语句，执行阶段不需要访问表或索引</li><li>system、const 表示可以对查询的某部分进行优化并将其转化成一个常量（<code>show warnings</code> 查看优化结果）</li><li>eq_ref 表示主键或唯一索引被连接使用，最多返回一条符合条件的记录</li><li>ref 比起前者，它不使用唯一索引，而使用普通索引或唯一索引的部分前缀，索引和某个值比较，找到多个符合条件的行</li><li>range 通常出现在范围查询中，使用索引来检索给定范围的行</li><li>index 扫描全索引得到结果，一般是扫描某个二级索引</li><li>all 表示全表扫描</li></ul></li><li>🌟<code>possible_key</code> 列：在查询中可能用到的索引，null 则表示没有相关索引【通过检查 where 子句查看是否可以添加一个适当的索引来提高性能】</li><li>🌟<code>key</code> 列：显示 MySQL 在实际查询时用到的索引，如果前者有值而该列为 null，则可能是表中数据不多，MySQL 认为索引对当前查询帮助不大而选择了全表查询</li><li><code>key_len</code> 列：显示 MySQL 在索引中使用的字节数，通过该数可以计算得出具体使用了索引中的哪些列</li><li><code>ref</code> 列：显示在 key 列记录的索引中，表查询时具体用到的列或常量</li><li><code>rows</code> 列：查询中估计要读取的行数（不是结果集的行数）</li><li><code>filter</code> 列：通过查询获取的最终记录行数占搜索行数的百分比</li><li><code>extra</code> 列： <ul><li>Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖</li><li>Using index：使用覆盖索引</li><li>Using index condition：查询的列不完全被索引覆盖，where条件中是一个查询的范围</li><li>Using temporary：MySQL 需要创建一张临时表来处理查询，这种情况一般需要进行优化</li><li>Using filesort：使用外部排序而不是索引排序，数据较小时从内存排序，否则在磁盘完成排序</li><li>Select tables optimized away：使用某些聚合函数（max、min 等）来访问存在索引的某个字段</li></ul></li></ul><p>实习项目：优化前和优化后（对 alarm_id 字段增加索引），响应时间从 949ms 降到 594ms</p>`,69),p=[c];function u(h,m){return a(),t("div",null,p)}const y=e(o,[["render",u],["__file","mysql.html.vue"]]);export{y as default};
